<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on 星期日, 七月 16, 2017, 7:05 下午 -->
<!-- MuClient version 5.05 -->

<!-- Plugin "GetFullmeImage" generated by Plugin Wizard -->

<!--
Get Fullme image and save it to the disk
-->

<muclient>
<plugin
   name="GetFullmeImage"
   author="potato"
   id="49d60313904dfdbd24b9bb30"
   language="Lua"
   purpose="Get Fullme image and save it to the disk"
   date_written="2017-07-16 18:41:46"
   requires="5.05"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Load Plugin GetFullmeImage
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="E:\games\mud\MUSHclient\worlds\plugins\constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   group="fullme"
   lines_to_match="2"
   match="^请注意，忽略验证码中的红色文字。.*$\n^(.*)$\n"
   multi_line="y"
   name="fullme_code_from_web"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>start_down_fullme_code_from_web("%1",true)</send>
  </trigger>

  <trigger
   enabled="y"
   group="fullme"
   lines_to_match="1"
   match="^你之前请求的fullme还没有完成。"
   multi_line="n"
   name="fullme_unfinished"
   regexp="y"
   sequence="100"
  >
  <send>fullme 剑法.</send>
  </trigger>

  <trigger
   enabled="y"
   group="fullme"
   lines_to_match="1"
   match="好像什么都没有发生，但是又好像有什么事情做错了。再来一次试试！"
   multi_line="n"
   name="fullme_unfinished2"
   regexp="y"
   sequence="100"
  >
  <send>fullme 剑法</send>
  </trigger>
  
  <trigger
   enabled="y"
   group="fullme"
   lines_to_match="1"
   match="太遗憾了。"
   multi_line="n"
   name="fullme_unfinished3"
   regexp="y"
   sequence="100"
  >
  <send>fullme</send>
  </trigger>
  
  <trigger
   enabled="y"
   group="fullme"
   lines_to_match="1"
   match="你没有请求 fullme 。"
   multi_line="n"
   name="fullme_unfinished4"
   regexp="y"
   sequence="100"
  >
  <send>fullme</send>
  </trigger>  
</triggers>

<!--  Aliases  -->
<aliases>
  <alias
   name="label"
   match="test (.*)$"
   enabled="y"
   echo_alias="y"
   expand_variables="y"
   group="group"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>start_down_fullme_code_from_web("%1",true)</send>
  </alias>
  <alias
   script="test_download_image_from_web"
   match="testdi"
   enabled="y"
   group="group"
   sequence="100"
  >
  <send></send>
  </alias>
  <alias
   script="change_image_dir"
   match="cid"
   enabled="y"
   group="group"
   sequence="100"
  >
  <send></send>
  </alias>
  <alias
   script="stop_download"
   match="sdl"
   enabled="y"
   group="group"
   sequence="100"
  >
  <send></send>
  </alias>
</aliases>

<!--  Timers  -->

<timers>
  <timer enabled="y" minute="8" second="0.00" offset_second="0.00" >
  <send>hpbrief</send>

  </timer>
  <timer name="timer_download_next" script="download_next" enabled="n" second="10.00" offset_second="0.00"    send_to="12"
    group="download_images" >
  </timer>
  <timer name="timer_stop_download" script="stop_download" enabled="n" minute="2" second="10.00" offset_second="0.00"    send_to="12"
    group="download_images" >
  </timer>
</timers>

<!--  Script  -->

<script>
<![CDATA[

require 'lfs'
-- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- --
GLOBAL_CURRENT_DIR = nil
GLOBAL_WORK_PATH = "E:\\program\\recognize_image"
GLOBAL_URL = nil
-- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- --
function get_html_entire_text(from_web_url)
	
	local html_entire_text
	Note("url="..from_web_url)
	
	assert (package.loadlib (GLOBAL_WORK_PATH.."\\code".."\\luacom.dll","luacom_open")) ()

	oXMLHTTP = assert (luacom.CreateObject ("MSXML2.XMLHTTP.3.0"), "cannot open MSXML2.XMLHTTP.3.0")

	--oXMLHTTP:Open("GET", from_web_url, false)
	oXMLHTTP:Open("POST", from_web_url, false)
	
	oXMLHTTP:setRequestHeader("User-Agent", "Mozilla/4.0")
	xpcall(oXMLHTTP:Send(),function() Note("Send...\n") end)
	
	if oXMLHTTP.readyState == 4 and oXMLHTTP.Status == 200 then
		html_entire_text = oXMLHTTP.responseText
	else
	    Note("Error,oXMLHTTP.Status="..oXMLHTTP.Status)
	end -- if

	oXMLHTTP = nil
	
	return html_entire_text
	
end -- get_html_entire_text()

-- -- -- -- -- -- -- -- -- --

function get_jpg_url(from_html_text)

	if from_html_text == nil or from_html_text == "" then
		return nil
	end -- if
	
	local html_text, jpg_url
	
	local html_length = string.len(from_html_text)

	if html_length >= 200 then
		
		jpg_url = string.match(from_html_text, "/b2evo_captcha_tmp.-jpg")
		jpg_url = "http://pkuxkx.net/antirobot" .. jpg_url
		
	else
		jpg_url = nil
		--close_window()
		Note("from_html_text="..from_html_text..";html_length="..tostring(html_length))
		Note("\n本插件靠“fullme”触发。“fullme验证码图片”仅在之后的1分钟内输入有效。")
		Note("本插件不能正确获得Web页面文件。\n")	
	end -- if
	
	--print(jpg_url)

	return jpg_url
end -- get_jpg_url()

-- -- -- -- -- -- -- -- -- --

function download_jpg(from_jpg_url)

	local oXMLHTTP
	local jpg_buffer
	
	assert (package.loadlib (GLOBAL_WORK_PATH.."\\luacom.dll","luacom_open")) ()

	oXMLHTTP = assert (luacom.CreateObject ("MSXML2.XMLHTTP.3.0"), "cannot open MSXML2.XMLHTTP.3.0")

	oXMLHTTP:Open("GET", from_jpg_url, false)
	oXMLHTTP:setRequestHeader("User-Agent", "Mozilla/4.0")
	oXMLHTTP:Send()

	if oXMLHTTP.readyState == 4 and oXMLHTTP.Status == 200 then
	
		jpg_buffer = oXMLHTTP.responseBody
 		
	end -- if

	oXMLHTTP = nil
	
	return jpg_buffer
end -- download_jpg()

function start_down_fullme_code_from_web(web_url,change_dir)
    ret=down_fullme_code_from_web(web_url,change_dir)
    if(ret==true) then
        start_download()
    else
        stop_download()
    end
end

function down_fullme_code_from_web(web_url,change_dir)

	GLOBAL_URL = web_url
	
	local jpg, png = nil

	local html_entire_text = get_html_entire_text(web_url) -- get the html text as a string from the url.

	local jpg_url = get_jpg_url(html_entire_text) -- get the .jpg file's url from the html text.
	
	local ret = false
	
	if html_entire_text ~= nil and jpg_url ~= nil then
		jpg = download_jpg(jpg_url) -- download the .jpg file from the jpg's url, and save it as a variable in memeory.
		if jpg ~= nil then
		    if(change_dir==true) then
		        change_image_dir()
		    end
    		if GLOBAL_CURRENT_DIR ~= nil then
                local jpg_name,ext = string.match(jpg_url, "([%w_]+)%.(jpg)")
                local curr_dir = GLOBAL_WORK_PATH.."\\"..GLOBAL_CURRENT_DIR
                local new_name = get_random_file_name(curr_dir,jpg_name,ext)
                local fullFileName = curr_dir.."\\"..new_name.."\."..ext
                local file,err = io.open(fullFileName,"wb")
                file:write(jpg)
                file:close()
                Note("Download and saved 1 image successfully.")
                ret = true
    		else
            	Note("无法保存fullme 图片。")
            	Note("GLOBAL_CURRENT_DIR ==nil")
            	ret = true
            end --if
		else
		    Note("无法获得fullme 图片。jpg==nil，")
		    ret = true
		end
	else
		
		Note("本次查询无法获得页面/文件。")
		ret = true
		
	end -- if html_entire_text ~= nil and jpg_url ~= nil
	
	jpg, png = nil

    return ret
end -- down_fullme_code_from_web(web_url)

function change_image_dir()
    local curr_date_str="source_"..os.date("%Y%m%d")
    local curr_work_path=GLOBAL_WORK_PATH.."\\"..curr_date_str
    if(file_exists(curr_work_path)==false) then
        local res,err=lfs.mkdir(curr_work_path)
        if(res==false) then
          Note("change_image_dir mkdir err="..err)
          return
        end
    end
    local subdir_name=get_random_str(curr_work_path)
    local fullFileName = curr_work_path.."\\"..subdir_name
    Note("fullFileName="..fullFileName)
    local res,err=lfs.mkdir(fullFileName)
    if(res==true) then
        GLOBAL_CURRENT_DIR=curr_date_str.."\\"..subdir_name
    else
      Note("mkdir err="..err)
    end
end --change_image_dir

function test_download_image_from_web()

	local jpg = nil

	local jpg_url = "http://img1qn.moko.cc/2017-07-11/638693bb-fcee-4fe6-b551-8b5fcb78817a.jpg" -- get the .jpg file's url from the html text.

    jpg = download_jpg(jpg_url) -- download the .jpg file from the jpg's url, and save it as a variable in memeory.
    
    if jpg ~= nil and GLOBAL_CURRENT_DIR ~= nil then
        local curr_dir = GLOBAL_WORK_PATH.."\\"..GLOBAL_CURRENT_DIR
        local jpg_name,ext = string.match(jpg_url, "/([%w%-_]+)%.(jpg)")
        local new_name = get_random_file_name(curr_dir,jpg_name,ext)
        local fullFileName = curr_dir.."\\"..new_name.."\."..ext
        local file,err = io.open(fullFileName,"wb")
        file:write(jpg)
        file:close()
    else
    	Note("无法保存fullme 图片。")
    	if jpg ==nil then
    	    Note("jpg ==nil")
    	end
    	if GLOBAL_CURRENT_DIR ==nil then
    	    Note("GLOBAL_CURRENT_DIR ==nil")
    	end			
    end --if
    
    jpg = nil

end -- test_download_image_from_web(web_url)

function file_exists(path)
  local fileinfo,err = lfs.attributes(path)
  return fileinfo ~= nil
end --file_exists(path)

function get_random_str(pre_path)
    math.randomseed(tostring(os.time()):reverse():sub(1, 6)) 
    local random_str=tostring(math.random(100000))
    local fullFileName = pre_path.."\\"..random_str
    while (file_exists(fullFileName)==true)
    do
        math.randomseed(tostring(os.time()):reverse():sub(1, 6))
        random_str=tostring(math.random(100000))
        fullFileName = pre_path.."\\"..random_str
    end
    return random_str
end --get_random_str

function get_random_file_name(pre_path,file_name,ext_name)
    local new_name=file_name
    local fullFileName = pre_path.."\\"..new_name.."."..ext_name
    while (file_exists(fullFileName)==true)
    do
        math.randomseed(tostring(os.time()):reverse():sub(1, 6))
        new_name=tostring(math.random(100000))
        fullFileName = pre_path.."\\"..new_name.."\."..ext_name
    end
    return new_name
end --get_random_file_name

function download_next()
    if(GLOBAL_URL~=nil) then
        local ret=down_fullme_code_from_web(GLOBAL_URL,false)
        if(ret==false) then
            stop_download()
        else
            Note("继续下一次。")
        end
    else
        Note("GLOBAL_URL==nil, cannot download next")
        stop_download()
    end
end

function start_download()
    Note("download started")
    EnableTimer("timer_download_next",true)
    ResetTimer("timer_download_next")

    EnableTimer("timer_stop_download",true)
    ResetTimer("timer_stop_download")
end
function stop_download()
    Note("download stopped")
    EnableTimer("timer_download_next",false)
    ResetTimer("timer_download_next")

    EnableTimer("timer_stop_download",false)
    ResetTimer("timer_stop_download")
--    Note("Reload plugin")
--    world.DoAfterSpecial(2, 'Note("Reload plugin result:"..ReloadPlugin("GetFullmeImage"))', sendto.script)
--    Note("Reload plugin end")
end



]]>
</script> 


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="GetFullmeImage:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
